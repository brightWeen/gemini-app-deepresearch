# DeepResearch AI - 多智能体架构设计

## 1. 概述

DeepResearch AI 是一个 Web 应用，它演示了一个协作式多智能体系统，用于对给定主题进行深入研究。该系统遵循一个结构化的、类似流水线的流程，其中不同的专业化 AI 智能体执行顺序任务，从规划研究开始，到生成一份经过审查的最终报告。

其核心思想是将一个复杂的认知任务（研究）分解为更小的、定义明确的子任务，每个子任务都由一个为此特定目的而优化的智能体来处理。与使用单一、庞大的提示相比，这种方法提高了最终输出的质量、结构和可靠性。

这些智能体的编排由前端应用程序处理，该程序为每个智能体的任务调用 Gemini API，并实时可视化整个过程。

## 2. 智能体角色与职责

该系统由四种不同的智能体角色组成。每个智能体都由 `gemini-2.5-flash` 模型驱动，但使用独特的系统指令和配置来使其行为专业化。

### a. 规划智能体 (Planner Agent)

-   **角色：** 创建一个结构化的研究计划。
-   **输入：** 用户提供的主题（例如，“量子计算的未来”）。
-   **行动：**
    -   分析主题，并将其分解为 3-5 个逻辑上连续的研究问题。
    -   识别并说明对用户意图所做的任何假设。
-   **Gemini 配置：**
    -   使用特定的 `systemInstruction` 来扮演专家级研究规划师的角色。
    -   `responseMimeType` 设置为 `"application/json"`。
    -   提供严格的 `responseSchema`，以确保输出是包含 `plan`（字符串数组）和 `assumptions`（字符串）的有效 JSON 对象。
-   **输出：** 一个 `ResearchPlan` 对象。

### b. 研究智能体 (Researcher Agent)

-   **角色：** 为特定问题查找并总结信息。
-   **输入：** 来自规划智能体 `plan` 中的单个研究问题。
-   **行动：**
    -   基于输入的问题执行搜索查询。
    -   将搜索结果的发现总结成一个简洁的、2-3 段的摘要。
-   **Gemini 配置：**
    -   使用 `googleSearch` 工具 (`tools: [{ googleSearch: {} }]`)。这将智能体的回答基于实时网络数据，使其适用于当前事件和事实查询。
    -   系统指令引导它成为一个勤奋的研究员，并提供事实性摘要。
-   **输出：** 一个包含文本 `summary` 和 `sources`（用于研究的网站）数组的对象。
-   **注意：** 应用程序并行运行多个研究智能体（最多 3 个），以加快数据收集阶段的速度。

### c. 写作智能体 (Writer Agent)

-   **角色：** 将研究发现合成为一份连贯的报告。
-   **输入：**
    -   原始主题。
    -   由研究智能体生成的所有摘要组成的数组。
-   **行动：**
    -   通读所有提供的研究摘要。
    -   将信息合成为一份结构良好、单一的报告。
    -   使用 Markdown 进行格式化以保证清晰度（标题、列表等）。
-   **Gemini 配置：**
    -   系统指令将其角色定义为专业的报告撰写者。
    -   明确告知它要专注于内容，避免对研究过程进行元评论。
-   **输出：** 一个包含 Markdown 格式最终报告的字符串。

### d. 审查智能体 (Reviewer Agent)

-   **角色：** 提供质量控制和建设性反馈。
-   **输入：** 由写作智能体生成的最终报告。
-   **行动：**
    -   批判性地审查报告的清晰度、事实准确性和连贯性。
    -   生成一个简短的、带项目符号的改进建议列表。
    -   如果报告质量很高，它会说明报告已准备好发布。
-   **Gemini 配置：**
    -   系统指令将其角色设定为批判性审查员。
    -   使用 `thinkingConfig: { thinkingBudget: 0 }` 以获得更快、更直接的响应，因为对于此审查任务，深度的“思考”不是那么关键。
-   **输出：** 一个包含审查意见和建议的字符串。

## 3. 执行流程与编排

整个过程在 `App.tsx` React 组件中进行管理。

1.  **初始化：** 用户输入一个主题并点击“开始研究”。UI 被禁用，并为所有智能体创建初始状态 (`AgentStatus.Idle`)。

2.  **步骤 1：规划 (串行)：**
    -   使用主题调用 `runPlannerAgent`。
    -   规划智能体卡片的状态更新为 `Working`。其输出被直接流式传输到 UI 以提供视觉反馈。
    -   一旦完成，其状态变为 `Done`。

3.  **步骤 2：研究 (并行)：**
    -   从规划智能体的输出中提取研究问题。
    -   启动一个 `Promise.all` 调用，为每个研究问题并发运行多个 `runResearcherAgent` 实例。
    -   每个对应的研究智能体卡片更新为 `Working`，其发现被流式传输到其输出面板。
    -   当每个研究员完成时，其状态变为 `Done`，并显示其找到的来源。

4.  **步骤 3：写作 (串行)：**
    -   在所有研究 promise 解析后，它们的集体摘要被传递给 `runWriterAgent`。
    -   写作智能体的状态变为 `Working`，报告被流式传输到其卡片。
    -   完成后，其状态设置为 `Done`。

5.  **步骤 4：审查 (串行)：**
    -   来自写作智能体的完整报告被传递给 `runReviewerAgent`。
    -   审查智能体的卡片更新为 `Working`，其审查意见被流式传输。
    -   然后其状态设置为 `Done`。

6.  **步骤 5：最终定稿：**
    -   来自写作智能体的最终报告显示在页面底部一个专用的、格式化的区域。
    -   UI 加载状态设置为 `false`。

## 4. 前端与状态管理

-   **组件结构：**
    -   `App.tsx`: 主容器组件，负责编排智能体工作流并管理所有应用程序状态。
    -   `AgentCard.tsx`: 一个可复用的组件，用于显示单个智能体的当前状态（`role`, `status`, `output`, `sources`）。其样式（颜色、边框）根据智能体的状态动态更新。
    -   `Spinner.tsx` / `Icon.tsx`: 用于 UI 元素的辅助组件。
-   **状态管理：**
    -   使用 `React.useState` 来管理状态，包括 `agents` 数组、`isLoading` 状态、`error` 消息和 `finalReport`。
    -   状态更新函数（`updateAgentState`, `setAgentOutput`）用于保持不可变性，并在智能体完成任务时触发重新渲染。
-   **实时反馈：** 应用程序通过将 Gemini API 的文本输出直接流式传输到相应的智能体卡片中，提供了高度响应的用户体验。这是通过将 `onStream` 回调函数从 `App` 组件向下传递到 `geminiService` 函数中实现的。

## 5. 服务层 (`geminiService.ts`)

该文件作为与 Gemini API 所有交互的专用层。

-   **抽象：** 它将 API 逻辑与 UI 组件隔离开来。每个智能体的功能都封装在自己的异步函数中（例如 `runPlannerAgent`）。
-   **关注点分离：** 这种设计使 `App.tsx` 组件更清晰，因为它不需要知道每个智能体的具体提示、工具或配置。它只需要调用相应的服务函数并处理返回的数据。
-   **配置：** 服务层中的每个函数都负责为其特定智能体设置正确的 `systemInstruction`、`tools`、`responseSchema` 和其他参数，确保每个智能体正确执行其专业任务。
